---
title: "구글 트렌드와 ChatGPT로 자동 블로그 포스트 작성 및 배포하기"
description: "최근 몇 년간 인공지능과 자동화 기술의 발전으로 콘텐츠 생성과 관리가 훨씬 더 효율적으로 변하고 있습니다. 이번 포스트에서는 구글 트렌드를 활용하여 인기 검색어를 가져오고, 이를 ChatGPT를 이용해 블로그 포스트로 작성한 후, 고스트(Ghost) 플랫폼에 자동 배포하는 방법에 대해..."
pubDate: 2024-07-05
---


최근 몇 년간 인공지능과 자동화 기술의 발전으로 콘텐츠 생성과 관리가 훨씬 더 효율적으로 변하고 있습니다. 이번 포스트에서는 구글 트렌드를 활용하여 인기 검색어를 가져오고, 이를 ChatGPT를 이용해 블로그 포스트로 작성한 후, 고스트(Ghost) 플랫폼에 자동 배포하는 방법에 대해 알아보겠습니다.
저도 파이썬을 잘 몰라서 쳇쥐피티에게 물어가며 작업을 완료했습니다. 이런 것이 가능하다는것에 약간의 감동했습니다.

## 사전준비파이썬이 깔려있어야 합니다. 저는 맥을 사용하므로 맥기준으로 brew install python 을 하시면되는데, brew는 또 뭐냐 하고 물으신다면, 터미널을 여시고 아래 명령어를 수행해주시면됩니

다.

```python
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

```

그리고 아무 폴더에 파일을 하나 생성합니다. 저는 vscode로 작업을 하였습니다. vscode가 뭐냐고 물으신다면…
[https://code.visualstudio.com/Download](https://code.visualstudio.com/Download)
공식사이트에서 받으시면 됩니다. 설치는 아래 링크를 참조하세요.
[https://birdspring.com/install-vscode/](__GHOST_URL__/install-vscode/)

## 구글 트렌드로 인기 검색어 가져오기구글 트렌드는 특정 기간 동안의 인기 검색어를 제공하는 유용한 도구입니다. 이를 통해 현재 사람들이 무엇에 관심을 가지고 있는지 파악할 수 있습니다. 구글 트렌드 API를 활용하면 자동으로 최신 인기 검색어 목록을 가져올 수 있습니

다.

```
from pytrends.request import TrendReq

# pytrends 초기화 및 트렌드 검색

pytrends = TrendReq(hl='ko', tz=540)
kw_list = [""]
pytrends.build_payload(kw_list, geo='KR', timeframe='now 1-d')
trending_searches_df = pytrends.trending_searches(pn='south_korea')
top_keywords = trending_searches_df[0].tolist()

# 트렌드 목록 출력

print("오늘의 대한민국 트렌드 키워드:")
for i, keyword in enumerate(top_keywords, 1):
    print(f"{i}. {keyword}")

```

쉽게 구글트랜드 를 가져올수 있네요. 그런데 잠깐 실행전에 해야할 일이 있습니다. 터미널에서 아래 명령어를 실행해주세요.
```
pip install requests
pip install pytrends
pip install markdown-it-py
pip install openai==0.28
pip install pyjwt
pip install pillow

```

저희가 직접 코드를 만들어야할 부분들을 좋으신 분들이 미리 만들어놓으셔서 설치해서 사용하는 거랍니다. 박수한번 쳐주세요!
자 처음 파이썬으로 프로그램을 만들었으니 실행을 해보세요. 실행은 어떻게 하냐구요? 위 내용으로 파일이름.py라는 파일을 저장하고 그파일이 있는 폴더에서 vscode의 터미널을 엽니다. 그리고 아래 명령어를 실행해 보세요.
```
python 파일이름.py

```

저도 실행해보니 아래와 같이 출력되네요. 잘되는 것 같습니다.
```
➜  python-app git:(main) ✗ python test1.py
오늘의 대한민국 트렌드 키워드:
1. 김해준
2. 비트코인
3. EWC
4. 아식스
5. 배우 강철
6. 해리스
7. 조현문
8. 니케
9. 배현진
10. 시청역 사고 토마토 주스
11. 시청역 역주행 사고
12. 김건희
13. 푸바오 할부지
14. 영국 총선
15. K리그1
16. 태풍
17. 대한항공 승무원 가방에서 실탄
18. 젠레스 존 제로
19. 남원시 식중독
20. 프랑스 엑스칼리버

```

## ChatGPT로 블로그 포스트 작성하기구글 트렌드에서 가져온 검색어를 바탕으로 ChatGPT를 이용해 블로그 포스트를 자동으로 작성할 수 있습니다. OpenAI의 GPT API를 이용하면 쉽게 구현할 수 있습니다.

두번째 파일을 만들고 아래 코드를 입력하고 저장해 볼꼐요. 그런데 openai를 사용해야하기 때문에 무료 사용자들은 chatgpt3.5를 사용하게 되요. 하지만 이정도 하는데 chatgpt4o정도는 써줘야하지 않겠습니까? 그래서 4o기준으로 코드를 만들어보겠습니다.
```
import openai

keyword = "비트코인"

# OpenAI API 키 설정

openai.api_key = '<OPENAI에서 발급받은 API KEY>'

def generate_blog_content(keyword):
    prompt = f"""
    {keyword}에 대해 블로그 포스트를 작성해주세요.
    최신 정보를 포함하도록 작성해주시고, 사실이 맞는지 체크를 해주세요.
    단락마다 달리3에서 단락의 내용에 맞는 이미지를 삽입해주세요.
    아래 형식으로 태그 목록도 포함해주세요:
## 태그

    TAG1,TAG2,TAG3,TAG4
    """
    response = openai.ChatCompletion.create(
        model="gpt-4o",
        messages = [
            {"role": "system", "content": "You are a helpful assistant that writes blog posts. 한글로 써줘."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=2048,
        temperature=0.7,
    )
    return response['choices'][0]['message']['content'].strip()

top_keyword_content = generate_blog_content(keyword)

if not top_keyword_content:
    print("블로그 콘텐츠 생성에 실패했습니다.")
    exit()

print(top_keyword_content)

```

마찬가지로 저장하고 실행해보면,
```python
➜  python-app python test2.py

# 비트코인: 디지털 시대의 혁신적인 자산

비트코인은 2009년에 처음 등장한 이후 디지털 자산의 대표주자로 자리매김했습니다. 사토시 나카모토라는 가명의 인물 또는 그룹에 의해 개발된 비트코인은 탈중앙화된 디지털 화폐로, 중앙은행이나 정부의 개입 없이 개인 간의 거래를 가능하게 합니다. 최근 몇 년간 비트코인의 가치는 폭발적으로 상승했고, 이에 따라 많은 투자자와 기업들이 관심을 보이고 있습니다. 이번 블로그 포스트에서는 비트코인의 최신 정보와 그 의미에 대해 알아보겠습니다.

## 비트코인의 최신 동

향

### 1. 202

3

년 비트코인 가격 동향

2023년 들어 비트코인의 가격은 큰 변동성을 보였습니다. 2023년 초에는 1.,000 이하로 하락했으나, 이후 기관 투자자들의 적극적인 매수와 글로벌 경제 상황의 변화로 인해 다시 상승세를 보였습니다. 2023년 10월 현재, 비트코인의 가격은 2.,000 이상에서 거래되고 있습니다. 이는 전 세계적인 인플레이션 우려와 안전자산 선호 현상이 맞물린 결과로 볼 수 있습니다.

### 2.

규

제와 정책 변화

각국 정부는 비트코인 및 암호화폐 시장에 대한 규제 방안을 계속해서 논의하고 있습니다. 미국 증권거래위원회(SEC)는 비트코인 ETF 승인 여부를 두고 신중한 태도를 보이고 있으며, 이는 시장에 큰 영향을 미치고 있습니다. 또한, 유럽연합(EU)은 암호화폐 규제를 강화하는 방향으로 정책을 조정하고 있어, 향후 비트코인 시장에 어떤 영향을 미칠지 주목됩니다.

### 3.

기

술 발전과 네트워크 확장

비트코인의 기술 발전도 눈여겨볼 만합니다. 라이트닝 네트워크(Lightning Network)와 같은 2차 레이어 솔루션이 활성화되면서 비트코인의 거래 속도와 확장성이 크게 향상되었습니다. 이는 비트코인의 실사용 사례를 더욱 확대시키고, 소액결제 등 다양한 분야에서의 활용 가능성을 높이고 있습니다.

## 비트코인의 미래 전

망

비트코인의 미래에 대한 전망은 여전히 많은 논란이 있지만, 그 가능성은 무궁무진합니다. 디지털 화폐로서의 역할을 넘어 '디지털 금'으로 평가받고 있는 비트코인은 장기적인 투자 자산으로서의 가치를 인정받고 있습니다. 또한, 블록체인 기술의 발전과 함께 다양한 산업 분야에서 비트코인의 활용 가능성이 더욱 확대될 것으로 기대됩니다.

## 결

론

비트코인은 단순한 디지털 화폐를 넘어선 혁신적인 자산입니다. 2023년 현재, 비트코인은 여전히 높은 변동성을 보이고 있지만, 그 잠재력과 가능성은 무한합니다. 앞으로도 비트코인의 발전과 변화에 주목하며, 현명한 투자와 활용 방안을 모색해 나가는 것이 중요합니다.

## 태

그

비트코인,암호화폐,블록체인,투자,디지털자산

---

위의 정보는 2023년 10월을 기준으로 작성되었으며, 비트코인의 가격과 관련된 최신 정보는 변동될 수 있습니다. 따라서 항상 최신 정보를 확인하고 투자 결정을 내리시기 바랍니다.

```

뭐 얼추 잘 나오기는 하는데, API로 사용하는 chatgpt는 인터넷 검색을 못하는 것 같습니다. 아쉬운 부분이네요. 실제로 달리3에서 그린 관련된 그림을 포함시켜달라고 해봤는데 그림도 못그립니다. 현재 기준으로 chatgpt-4o에서는 답변해주는 본문에 이미지도 그려줍니다. 그래도 뭐 방법은 있습니다! 달리3 api를 사용해도 될것 같고 저는 로컬에서 스테이블 디퓨전 webui를 설치해서 연동을 해서 블로그의 해더이미지를 설정해보려고 합니다. 이 부분은 다음 단락에서 한번에 추가해서 위에 만든 프로그램까지 모두 연동해보겠습니다.

## 고스트(Ghost) 플랫폼에 자동 배포하기이제 작성된 블로그 포스트를 고스트 플랫폼에 자동으로 배포해봅시다. 고스트는 API를 통해 콘텐츠를 관리할 수 있는 기능을 제공합니다. 기능이 많아서 아래 코드의 주석으로 설명을 하려고 합니다. 주석을 잘 봐주세

요.

```
from pytrends.request import TrendReq
import openai
import jwt as pyjwt
import time
import requests
import os
import json
import re
from markdown_it import MarkdownIt
from markdown_it.token import Token
from PIL import Image
import base64
import io

# 쳇쥐피티에서 마크다운으로 생성된 컨텐츠를 ghost용인 lexical로 변경하는 함수

def markdown_to_lexical(markdown_content):
    md = MarkdownIt()
    tokens = md.parse(markdown_content)

    lexical_content = {
        "root": {
            "children": [],
            "type": "root",
            "version": 1
        }
    }

    current_node = lexical_content["root"]["children"]

    for token in tokens:
        if token.type == "heading_open":
            level = int(token.tag[1])
            current_node.append({
                "type": "heading",
                "tag": f"h{level}",
                "children": []
            })
            current_node = current_node[-1]["children"]
        elif token.type == "heading_close":
            current_node = lexical_content["root"]["children"]
        elif token.type == "paragraph_open":
            current_node.append({
                "type": "paragraph",
                "children": []
            })
            current_node = current_node[-1]["children"]
        elif token.type == "paragraph_close":
            current_node = lexical_content["root"]["children"]
        elif token.type == "inline":
            for child in token.children:
                if child.type == "text":
                    current_node.append({
                        "type": "text",
                        "text": child.content
                    })

    return lexical_content

# 고스트의 태그 부분을 체워주기위해서 마크다운컨텐츠에서 태그 부분만 추출하는 함수

def extract_tags(markdown_content):
# '## 태그' 이후의 내용을 추출하여 태그 배열로 변환

    tag_section = re.search(r'## 태그\n(.+)', markdown_content)
    if tag_section:
        tags_line = tag_section.group(1).strip()
        tags = tags_line.split(',')
        return [tag.strip() for tag in tags]  # 태그들을 배열로 변환하고 공백 제거
    return []

# 고스트의 제목 부분을 설정하기위해서 마크다운 컨텐츠에서 제목 부분만 추출하는 함수

def extract_title(markdown_content):
# 첫 번째 제목(# )을 추출

    match = re.search(r'^# (.+)', markdown_content, re.MULTILINE)
    if match:
        return match.group(1)
    return "Untitled"

# pytrends 초기화 및 트렌드 검색

pytrends = TrendReq(hl='ko', tz=540)
kw_list = [""]
pytrends.build_payload(kw_list, geo='KR', timeframe='now 1-d')
trending_searches_df = pytrends.trending_searches(pn='south_korea')
top_keywords = trending_searches_df[0].tolist()

# 트렌드 목록 출력

print("오늘의 대한민국 트렌드 키워드:")
for i, keyword in enumerate(top_keywords, 1):
    print(f"{i}. {keyword}")

# 사용자 입력을 통한 키워드 선택 또는 수동 입력

user_input = input("원하는 키워드의 번호를 입력하세요 (또는 수동으로 입력하려면 엔터를 누르세요): ").strip()

if user_input:
    keyword_index = int(user_input) - 1
    keyword = top_keywords[keyword_index]
else:
    keyword = input("수동으로 키워드를 입력하세요: ").strip()

if not keyword:
    print("키워드가 없습니다. 프로그램을 종료합니다.")
    exit()

# OpenAI API 키 설정

openai.api_key = '<OpenAI 에서 발급받은 API KEY>'

# 앞에서 만든 쳇쥐피티한테 블로그를 써달라고 요청하는 함수

def generate_blog_content(keyword):
    prompt = f"""
    {keyword}에 대해 블로그 포스트를 작성해주세요.
    최신 정보를 포함하도록 작성해주시고, 사실이 맞는지 체크를 해주세요.
    단락마다 달리3에서 단락의 내용에 맞는 이미지를 삽입해주세요.
    아래 형식으로 태그 목록도 포함해주세요:
## 태그

    TAG1,TAG2,TAG3,TAG4
    """
    response = openai.ChatCompletion.create(
        model="gpt-4o",
        messages = [
            {"role": "system", "content": "You are a helpful assistant that writes blog posts. 한글로 써줘."},
            {"role": "user", "content": prompt}
        ],
        max_tokens=2048,
        temperature=0.7,
    )
    return response['choices'][0]['message']['content'].strip()

top_keyword_content = generate_blog_content(keyword)

if not top_keyword_content:
    print("블로그 콘텐츠 생성에 실패했습니다.")
    exit()

print(top_keyword_content)

# 마크다운을 Lexical 콘텐츠로 변환

lexical_content = markdown_to_lexical(top_keyword_content)

# 태그를 추출

tags = extract_tags(top_keyword_content)

# 제목을 추출

title = extract_title(top_keyword_content)
if not title:
    title = keyword

# Ghost Admin API 정보

ghostBlogDomain = "<고스트 블로그 도메인 주소>"
admin_api_url = f"{ghostBlogDomain}/ghost/api/admin/posts/"
admin_api_key = "<고스트 관리자에서 발급받은 admin api key>"
content_api_key = "<고스트 관리자에서 발급받은 content api key>"

# JWT 생성

iat = int(time.time())
header = {'alg': 'HS256', 'typ': 'JWT', 'kid': admin_api_key.split(':')[0]}
payload = {
    'iat': iat,
    'exp': iat + 5 * 60,  # 토큰 유효 시간: 5분
    'aud': '/admin/'
}
secret = bytes.fromhex(admin_api_key.split(':')[1])
token = pyjwt.encode(payload, secret, algorithm='HS256', headers=header)

# 이미지 생성 함수 로털에 설치한 스테이블 디퓨전을 사용함

# 스테이블 디퓨전을 실행할 때 --api옵션을 줘야함.

# 그래야지 /sdapi/v1/txt2img 라는 api를 사용할 수 있음.

# 원하는 이미지를 출력하기 위해서는 스테이블 디퓨전에 세팅이 좀 되어있어야함.

# 아래 설정들도 좀 배워야 이쁜이미지를 만들 수 있음.

def generate_image(prompt):
    url = "http://127.0.0.1:7860/sdapi/v1/txt2img"
    payload = {
        "prompt": prompt,
        "negative_prompt": "(easynegative:1.2), (Nipples, Clipping:1.2), (Bad Quality:1.5) (covered nipples:1), watermark, signature, name, brand",
        "steps": 4,
        "cfg_scale": 2,
        "sampler": "DPM++ SDE",
        "seed": 1699193547,
        "size": [768, 1152],
        "model": "realisticVisionV60B1_v51HyperVAE",
        "version": "v1.9.4",
        "model_hash": "f47e942ad4",
        "schedule_type": "Karras",
        "ADetailer_model": "mediapipe_face_full",
        "Hypertile_U-Net": True,
        "ADetailer_version": "24.5.1",
        "denoising_strength": 0.45,
        "ADetailer_mask_blur": 4,
        "ADetailer_model_2nd": "mediapipe_face_mesh_eyes_only",
        "ADetailer_confidence": 0.3,
        "ADetailer_dilate_erode": 4,
        "ADetailer_mask_blur_2nd": 4,
        "ADetailer_confidence_2nd": 0.3,
        "ADetailer_inpaint_padding": 32,
        "ADetailer_ControlNet_model": "control_v11p_sd15_inpaint [ebff9138]",
        "ADetailer_dilate_erode_2nd": 4,
        "ADetailer_ControlNet_module": "inpaint_global_harmonious",
        "ADetailer_ControlNet_weight": 0.8,
        "ADetailer_denoising_strength": 0.4,
        "ADetailer_inpaint_only_masked": True,
        "ADetailer_inpaint_padding_2nd": 32,
        "ADetailer_ControlNet_model_2nd": "control_v11p_sd15_inpaint [ebff9138]",
        "ADetailer_ControlNet_module_2nd": "inpaint_global_harmonious",
        "ADetailer_denoising_strength_2nd": 0.4,
        "ADetailer_inpaint_only_masked_2nd": True
    }
    response = requests.post(url, json=payload)
    if response.status_code == 200:
        image_data = response.json()["images"][0]
        image_bytes = base64.b64decode(image_data)
        return Image.open(io.BytesIO(image_bytes))
    else:
        print(f"이미지 생성 실패: {response.status_code}")
        return None

stable_d_prompt = ""
if tags:
    stable_d_prompt = ', '.join(map(str, tags))
else:
    stable_d_prompt = title

## 해더 이미지 생

성

# 여기서 스테이블 디퓨전용 프롬프트를 입력해야하는데 일단 임시로 태그 목록을 입력하게 했음

header_image = generate_image(stable_d_prompt)

if not header_image:
    print("헤더 이미지 생성에 실패했습니다.")
    exit()

# 이미지 파일로 저장

# 스테이블 디퓨전에서 png로 이미지를 주는데 아래 save부분에서 WEBP로 저장함.

header_image_path = "header_image.webp"
header_image.save(header_image_path, "WEBP")

# 이미지를 고스트로 업로드하는 함수

def upload_image(image_path):
    headers = {
        'Authorization': f'Ghost {token}',
# 'Content-Type': 'multipart/form-data'

    }
    with open(image_path, 'rb') as img_file:
        files = {'file': (header_image_path, img_file, 'image/webp')}
        response = requests.post(f"{ghostBlogDomain}/ghost/api/admin/images/upload/", headers=headers, files=files)
        if response.status_code == 201:
            return response.json()['images'][0]['url']
        else:
            print(f"이미지 업로드 실패: {response.status_code}")
            return None

# 헤더 이미지 업로드 - 스테이블 디퓨전이 로컬에 없다면 주석처리하고

# 아래에 post_data에서 feature_image부분도 제거하면됨.

header_image_url = upload_image(header_image_path)
if not header_image_url:
    print("헤더 이미지 업로드에 실패했습니다.")
    exit()

# 새로운 포스트 데이터

post_data = {
    "posts": [
        {
            "title": title,
            "slug": title,
            "status": "draft", # draft, published
            "visibility": "public",
            "lexical": json.dumps(lexical_content, ensure_ascii=False),  # Lexical 콘텐츠를 JSON 문자열로 변환
            "tags": tags,
            "feature_image": header_image_url  # 헤더 이미지 설정
        }
    ]
}

# HTTP 요청 헤더

headers = {
    'Authorization': f'Ghost {token}',
    'Content-Type': 'application/json'
}

# 포스트 생성 요청

try:
    response = requests.post(admin_api_url, json=post_data, headers=headers)
    if response.status_code == 201:
        print("포스트가 성공적으로 생성되었습니다!")
    else:
        print(f"포스트 생성에 실패했습니다. 상태 코드: {response.status_code}")
        print(response.json())
except requests.exceptions.RequestException as e:
    print(f"Ghost API 호출 중 오류 발생: {e}")

```

코드는 적당한 이름으로 저장하고 실행해보면, 아래와같이 잘 동작하는 것을 볼 수 있습니다.
```
➜  python-app git:(main) ✗ python3 AutoBlogPosting.p
y
오늘의 대한민국 트렌드 키워드:
1. 김해준
2. 비트코인
3. EWC
4. 아식스
5. 배우 강철
6. 해리스
7. 조현문
8. 니케
9. 배현진
10. 시청역 사고 토마토 주스
11. 시청역 역주행 사고
12. 김건희
13. 푸바오 할부지
14. 영국 총선
15. K리그1
16. 태풍
17. 대한항공 승무원 가방에서 실탄
18. 젠레스 존 제로
19. 남원시 식중독
20. 프랑스 엑스칼리버
원하는 키워드의 번호를 입력하세요 (또는 수동으로 입력하려면 엔터를 누르세요): 
수동으로 키워드를 입력하세요: 구글트랜드로 검색어를 가져와서 쳇쥐피티가 블로그 포스트를 작성하고 고스트에 자동배포

# 구글 트렌드와 ChatGPT로 자동 블로그 포스트 작성 및 배포하기

최근 몇 년간 인공지능과 자동화 기술의 발전으로 콘텐츠 생성과 관리가 훨씬 더 효율적으로 변하고 있습니다. 이번 포스트에서는 구글 트렌드를 활용하여 인기 검색어를 가져오고, 이를 ChatGPT를 이용해 블로그 포스트로 작성한 후, 고스트(Ghost) 플랫폼에 자동 배포하는 방법에 대해 알아보겠습니다.

![구글 트렌드와 ChatGPT](https://cdn.dall-e.com/images/google_trends_chatgpt.jpg)

## 구글 트렌드로 인기 검색어 가져오

기

구글 트렌드는 특정 기간 동안의 인기 검색어를 제공하는 유용한 도구입니다. 이를 통해 현재 사람들이 무엇에 관심을 가지고 있는지 파악할 수 있습니다. 구글 트렌드 API를 활용하면 자동으로 최신 인기 검색어 목록을 가져올 수 있습니다.

`python
import requests
import pandas as pd

# 구글 트렌드 API 엔드포인트와 파라미터 설정

url = "https://trends.google.com/trends/api/dailytrends"
params = {
    "hl": "ko",
    "tz": "-540",
    "geo": "KR"
}

response = requests.get(url, params=params)
data = response.json()

# 인기 검색어 목록 추출

trending_searches = data['default']['trendingSearchesDays'][0]['trendingSearches']
search_terms = [search['title']['query'] for search in trending_searches]

print(search_terms)
`

![구글 트렌드 데이터](https://cdn.dall-e.com/images/google_trends_data.jpg)

## ChatGPT로 블로그 포스트 작성하

기

구글 트렌드에서 가져온 검색어를 바탕으로 ChatGPT를 이용해 블로그 포스트를 자동으로 작성할 수 있습니다. OpenAI의 GPT API를 이용하면 쉽게 구현할 수 있습니다.

`python
import openai

openai.api_key = 'your_openai_api_key'

def generate_blog_post(search_term):
    prompt = f"Write a blog post about {search_term} in Korean."
    response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=prompt,
        max_tokens=500
    )
    return response.choices[0].text.strip()

for term in search_terms:
    post = generate_blog_post(term)
    print(post)
`

![ChatGPT 블로그 포스트](https://cdn.dall-e.com/images/chatgpt_blog_post.jpg)

## 고스트(Ghost) 플랫폼에 자동 배포하

기

이제 작성된 블로그 포스트를 고스트 플랫폼에 자동으로 배포해봅시다. 고스트는 API를 통해 콘텐츠를 관리할 수 있는 기능을 제공합니다.

`python
import requests

def post_to_ghost(title, content):
    url = "https://your_ghost_blog_url/ghost/api/v3/admin/posts/"
    headers = {
        "Authorization": "Ghost Admin API Key",
        "Content-Type": "application/json"
    }
    data = {
        "posts": [
            {
                "title": title,
                "html": content,
                "status": "published"
            }
        ]
    }
    response = requests.post(url, headers=headers, json=data)
    return response.json()

for term in search_terms:
    post = generate_blog_post(term)
    post_to_ghost(term, post)
`

![고스트 플랫폼 배포](https://cdn.dall-e.com/images/ghost_platform_deployment.jpg)

## 결

론

위 과정을 통해 구글 트렌드에서 인기 검색어를 가져오고, ChatGPT를 이용해 블로그 포스트를 작성한 후, 고스트 플랫폼에 자동으로 배포하는 전 과정을 살펴보았습니다. 이 방법을 활용하면 최신 트렌드에 맞춘 콘텐츠를 효율적으로 생성하고 관리할 수 있습니다.

## 태

그

구글트렌드,ChatGPT,고스트,자동화,API

![최종 이미지](https://cdn.dall-e.com/images/final_image.jpg)
포스트가 성공적으로 생성되었습니다!

```## 결론위 과정을 통해 구글 트렌드에서 인기 검색어를 가져오고, ChatGPT를 이용해 블로그 포스트를 작성한 후, 고스트 플랫폼에 자동으로 배포하는 전 과정을 살펴보았습니다. 이 방법을 활용하면 최신 트렌드에 맞춘 콘텐츠를 효율적으로 생성하고 관리할 수 있습니다.
(헐 해당 포스팅도 위 코드를 활용했다는걸 들켜버렸네요)

## 태그구글트렌드,ChatGPT,고스트,자동화,AP

I